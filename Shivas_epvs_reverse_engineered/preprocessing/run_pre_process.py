#! /usr/bin/env python3
'''this scripts batch preprocess the images, it runs pre_process.py for each image in the image_dir'''
'''and write the output in the images_output_dir'''
'''the input images in the image_dir are expected to be in the format of nii'''
'''the input images are in two layers folder in the following format '''
'''image_dir/subject_id/scan_id/scan_id_Hires.nii'''
'''the output image are going to be saved in the images_output_dir in a flat structure'''
'''images_output_dir/scan_id_Hires_preprocessed.nii'''

'''write a python script to do this'''

''' SCRIPT MOSTLY GENERATED BY CURSOR AND CLAUDE SONNET PLEASE USE WITH CAUTION'''
import os
import json
from pathlib import Path
import SimpleITK as sitk
import numpy as np

def load_config(config_path):
    with open(config_path, 'r') as f:
        return json.load(f)

def resize_image(image, target_shape):
    """Resizes the 3D image to the target shape using SimpleITK."""
    original_size = np.array(image.GetSize())
    target_size = np.array(target_shape)
    resize_factor = target_size / original_size
    resampler = sitk.ResampleImageFilter()
    resampler.SetSize([int(sz) for sz in target_size])
    resampler.SetOutputSpacing(image.GetSpacing() / resize_factor)
    resampler.SetInterpolator(sitk.sitkLinear)
    resampler.SetOutputDirection(image.GetDirection())
    resampler.SetOutputOrigin(image.GetOrigin())
    return resampler.Execute(image)

def normalize_image(image, brain_mask=None):
    """Normalizes voxel values to [0, 1] using min-max normalization."""
    image_array = sitk.GetArrayFromImage(image)
    if brain_mask is not None:
        mask_array = sitk.GetArrayFromImage(brain_mask)
        brain_voxels = image_array[mask_array > 0]
    else:
        brain_voxels = image_array

    # Calculate the 99th percentile value for normalization
    max_val = np.percentile(brain_voxels, 99)
    min_val = np.min(brain_voxels)

    # Clip values to avoid hot spots and scale to [0, 1]
    normalized_array = np.clip((image_array - min_val) / (max_val - min_val), 0, 1)

    return sitk.GetImageFromArray(normalized_array)

def center_brain(image, brain_mask=None):
    """Centers the brain within the image using the brain mask if available."""
    image_array = sitk.GetArrayFromImage(image)
    if brain_mask is not None:
        mask_array = sitk.GetArrayFromImage(brain_mask)
        brain_indices = np.array(np.nonzero(mask_array))
    else:
        brain_indices = np.array(np.nonzero(image_array))

    brain_center = np.mean(brain_indices, axis=1).astype(int)
    image_center = np.array(image_array.shape) // 2

    # Compute shifts needed to center the brain
    shifts = image_center - brain_center

    # Apply shifts using numpy roll
    centered_array = np.roll(image_array, shifts, axis=(0, 1, 2))

    return sitk.GetImageFromArray(centered_array)

def register_t2_to_hires(hires_image, t2_image):
    """Register T2 image to Hires image using affine registration."""
    registration_method = sitk.ImageRegistrationMethod()
    registration_method.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)
    registration_method.SetOptimizerAsGradientDescent(learningRate=0.0001, numberOfIterations=100)
    registration_method.SetInitialTransform(sitk.AffineTransform(3))
    registration_method.SetInterpolator(sitk.sitkLinear)

    final_transform = registration_method.Execute(sitk.Cast(hires_image, sitk.sitkFloat32),
                                                  sitk.Cast(t2_image, sitk.sitkFloat32))

    return sitk.Resample(t2_image, hires_image, final_transform, sitk.sitkLinear, 0.0, t2_image.GetPixelID())

def divide_hires_by_t2(hires_image, t2_image):
    """Divide Hires image by T2 image voxelwise."""
    hires_array = sitk.GetArrayFromImage(hires_image)
    t2_array = sitk.GetArrayFromImage(t2_image)
    
    # Avoid division by zero
    t2_array[t2_array == 0] = 1e-6
    # ensure float division
    
    result_array = np.float32(hires_array)/ np.float32(t2_array)
    return sitk.GetImageFromArray(result_array)

def process_nifti_image(hires_path, t2_path, output_path, target_shape=(160, 214, 176), apply_brain_mask=True):
    # Load the Hires and T2 NIfTI images
    hires_img = sitk.ReadImage(hires_path)
    t2_img = sitk.ReadImage(t2_path)

    # Register T2 to Hires
    registered_t2 = register_t2_to_hires(hires_img, t2_img)
    # save the registered t2 image
    sitk.WriteImage(registered_t2, output_path.parent / f"{output_path.stem}_registered.nii")
    # Divide Hires by registered T2
    divided_img = divide_hires_by_t2(hires_img, registered_t2)

    # Resize the image to target shape
    resized_image = resize_image(divided_img, target_shape)

    # Normalize voxel values
    normalized_image = normalize_image(resized_image)

    # Center the brain within the image
    centered_image = center_brain(normalized_image)

    # Set metadata (direction, spacing, origin) from the original image
    centered_image.SetDirection(hires_img.GetDirection())
    centered_image.SetSpacing([1.0, 1.0, 1.0])  # Set isotropic spacing (1mmÂ³)
    centered_image.SetOrigin(hires_img.GetOrigin())

    # Save the processed image
    sitk.WriteImage(centered_image, output_path)

def main():
    # load the config file which is expected to be in the parent directory
    config_path = Path(__file__).parent.parent / 'config.json'
    config = load_config(config_path)

    # get the image directory and the output directory from the config file
    image_dir = Path(config['raw_image_dir'])
    output_dir = Path(config['enhanced_images_output_dir'])
    output_prefix = config['output_image_prefix']
    verbose = config['verbose']

    output_dir.mkdir(parents=True, exist_ok=True)

    for subject_dir in image_dir.iterdir():
        if subject_dir.is_dir():
            for scan_dir in subject_dir.iterdir():
                if scan_dir.is_dir():
                    hires_file = next(scan_dir.glob('*_Hires.nii'), None)
                    t2_file = next(scan_dir.glob('*_T2.nii'), None)
                    if hires_file and t2_file:
                        output_file = output_dir / f"{scan_dir.name}_{output_prefix}.nii"
                        process_nifti_image(hires_file, t2_file, output_file)
                        if verbose:
                            print(f"Preprocessed: {hires_file} and {t2_file} -> {output_file}")

if __name__ == "__main__":
    main()










